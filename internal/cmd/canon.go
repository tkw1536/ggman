package cmd

//spellchecker:words github cobra ggman internal pkglib exit
import (
	"fmt"

	"github.com/spf13/cobra"
	"go.tkw01536.de/ggman/internal/env"
	"go.tkw01536.de/pkglib/exit"
)

//spellchecker:words github cobra ggman goprogram exit cspec

func NewCanonCommand() *cobra.Command {
	impl := new(canon)

	cmd := &cobra.Command{
		Use:   "canon URL [CANSPEC]",
		Short: "Print the canonical version of a URL",
		Long: `Canon prints to standard output the canonical version of the URL passed as the first argument.
An optional second argument determines the CANSPEC to use for canonizing the URL.

On github.com and multiple other forges, it is usually possible to clone repositories via multiple urls. 
For example, the repository https://github.com/hello/world can actually be cloned via:
- https://github.com/hello/world.git
- git@github.com:hello/world.git

Usually the latter url is preferred over the former one in order to use SSH authentication instead of having to constantly having to type a password. 
For this purpose, ggman implements the concept of canonical urls, that is it treats the latter url as the main one and uses it to clone the repository. 
This behavior can be customized by the user. 

A canonical url is generated from an original url using a so-called CANSPEC (canonical specification).
An example CANSPEC is 'git@^:$.git'. 

CANSPECs generate canonical urls by first taking the original urls, and splitting them into path-like components. 
These components also perform some normalization, such as removing common prefixes and suffixes. 
A few examples:

- 'git@github.com/user/repo' => 'github.com', 'user', 'repo'
- 'github.com/hello/world.git' => 'github.com', 'hello', 'world'
- 'user@server.com:repo.git' => 'server.com', 'user', 'repo'

To see exactly which components a URL has, use 'ggman comps <URL>'.

After this, the canonical url is generated by parsing each character of the CANSPEC.
By default, a character of the CANSPEC simply ends up in the canonical url. 
However, two characters are treated differently:
- '%' is replaced by the second unused component of the URI (commonly a username)
- '$' is replaced by all remaining components in the URI joined with a '/'. Also stops all special character processing afterwards. 
If '$' does not exist in the cspec, it is assumed to be at the end of the CANSPEC.
Furthermore, the special CANSPEC '$$' always the original url unchanged.

A couple of examples (for components 'server.com', 'user', 'repository'):

- 'git@^:$.git' => 'git@server.com:user/repository.git'
- 'ssh://%@^/$.git' => 'ssh://user@server.com/repository.git'
- (empty) => 'server.com/user/repository'

To get the canonical url of a repository use 'ggman canon <URL> <CANSPEC>'. 

To customize the behavior globally, a so-called CANFILE can be used. 
This CANFILE should either be called '.ggman' in the users home directory, or be pointed to by the 'GGMAN_CANFILE' environment variable. 

A CANFILE should consist of several lines.
Each line should contain either one or two space-separated strings. 
The first one is a pattern (as used with the 'for' keyword) and the second is a CANSPEC to apply for all repositories matching this pattern. 
Empty lines and those starting with '#', '\' are treated as comments.

An example CANFILE might be:

` + "```" + `
  # for anything on git.example.com, clone with https
  ^git.example.com https://$.git

  # for anything on git2.example.com leave the urls unchanged
  ^git2.example.com $$

  # by default, clone via ssh
  git@^:$.git
` + "```" + `
To resolve a canonical url with a CANFILE, simply omit the CANSPEC attribute of 'ggman canon'. 
`,
		Args: cobra.RangeArgs(1, 2),

		PreRunE: impl.ParseArgs,
		RunE:    impl.Exec,
	}

	return cmd
}

type canon struct {
	Positional struct {
		URL     env.URL
		CANSPEC string
	}
}

var (
	errCanonUnableCanFile = exit.NewErrorWithCode("unable to load default CANFILE", env.ExitContext)
)

func (c *canon) ParseArgs(cmd *cobra.Command, args []string) error {
	c.Positional.URL = env.ParseURL(args[0])
	if len(args) == 2 {
		c.Positional.CANSPEC = args[1]
	}
	return nil
}

func (c *canon) Exec(cmd *cobra.Command, args []string) error {
	var file env.CanFile

	if c.Positional.CANSPEC == "" {
		env, err := env.GetEnv(cmd, env.Requirement{})
		if err != nil {
			return fmt.Errorf("failed to get environment: %w", err)
		}

		if file, err = env.LoadDefaultCANFILE(); err != nil {
			return fmt.Errorf("%w: %w", errCanonUnableCanFile, err)
		}
	} else {
		file = []env.CanLine{{Pattern: "", Canonical: c.Positional.CANSPEC}}
	}

	// print out the canonical version of the file
	canonical := c.Positional.URL.CanonicalWith(file)

	if _, err := fmt.Fprintln(cmd.OutOrStdout(), canonical); err != nil {
		return fmt.Errorf("%w: %w", errGenericOutput, err)
	}
	return nil
}
